'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _update = require('../scripts/update');

var _update2 = _interopRequireDefault(_update);

var _runWithTruffle = require('../utils/runWithTruffle');

var _runWithTruffle2 = _interopRequireDefault(_runWithTruffle);

var _input = require('../utils/input');

var _naming = require('../utils/naming');

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const name = 'update';
const signature = `${name} [alias-or-address]`;
const description = 'update contract to a new logic. Provide the [alias] or [package]/[alias] you added your contract with, its [address], or use --all flag to update all contracts in your project.';

const register = program => program.command(signature, { noHelp: true }).usage('[alias-or-address] --network <network> [options]').description(description).option('--init [function]', `call function after upgrading contract. If no name is given, 'initialize' will be used`).option('--args <arg1, arg2, ...>', 'provide initialization arguments for your contract if required').option('--all', 'update all contracts in the application').option('--force', 'force creation even if contracts have local modifications').withNetworkOptions().action(action);

async function action(contractFullNameOrAddress, options) {
  const { initMethod, initArgs } = (0, _input.parseInit)(options, 'initialize');
  const { all, force } = options;

  let proxyAddress, contractAlias, packageName;
  if (contractFullNameOrAddress && contractFullNameOrAddress.startsWith('0x')) {
    proxyAddress = contractFullNameOrAddress;
  } else if (contractFullNameOrAddress) {
    ({ contract: contractAlias, package: packageName } = (0, _naming.fromContractFullName)(contractFullNameOrAddress));
  }

  const args = _lodash2.default.pickBy({ contractAlias, packageName, proxyAddress, initMethod, initArgs, all, force });
  await (0, _runWithTruffle2.default)(async opts => await (0, _update2.default)(_extends({}, args, opts)), options);
}

exports.default = { name, signature, description, register, action };