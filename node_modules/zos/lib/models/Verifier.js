'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _querystring = require('querystring');

var _querystring2 = _interopRequireDefault(_querystring);

var _axios = require('axios');

var _axios2 = _interopRequireDefault(_axios);

var _cheerio = require('cheerio');

var _cheerio2 = _interopRequireDefault(_cheerio);

var _zosLib = require('zos-lib');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const log = new _zosLib.Logger('Verifier');

const Verifier = {
  async verifyAndPublish(remote, params) {
    if (remote === 'etherchain') {
      await publishToEtherchain(params);
    } else {
      throw new Error('Invalid remote. Currently, ZeppelinOS contract verifier only supports etherchain as remote verification application.');
    }
  }
};

async function publishToEtherchain(params) {
  const etherchainVerificationUrl = 'https://www.etherchain.org/tools/verifyContract';
  const etherchainContractUrl = 'https://www.etherchain.org/account';
  const { compilerVersion, optimizer, contractAddress } = params;
  const compiler = `soljson-v${compilerVersion.replace('.Emscripten.clang', '')}.js`;
  const optimizerStatus = optimizer ? 'Enabled' : 'Disabled';

  try {
    const response = await _axios2.default.request({
      method: 'POST',
      url: etherchainVerificationUrl,
      data: _querystring2.default.stringify(_extends({}, params, { compilerVersion: compiler, optimizer: optimizerStatus })),
      headers: {
        'Content-type': 'application/x-www-form-urlencoded'
      }
    });
    if (response.status === 200) {
      const html = _cheerio2.default.load(response.data);
      const message = html('#infoModal .modal-body').text();
      if (message.match(/successful/)) {
        log.info(`Contract verified and published successfully. You can check it here: ${etherchainContractUrl}/${contractAddress}#code`);
      } else if (message.match(/^No[\w\s]*provided\.$/)) {
        throw new Error(`Error during contract verification: ${message}`);
      } else {
        throw new Error(message);
      }
    }
  } catch (error) {
    throw Error(error.message || 'Error while trying to publish contract');
  }
}

exports.default = Verifier;