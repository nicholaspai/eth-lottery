'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _Session = require('../network/Session');

var _Session2 = _interopRequireDefault(_Session);

var _Truffle = require('../truffle/Truffle');

var _Truffle2 = _interopRequireDefault(_Truffle);

var _zosLib = require('zos-lib');

var _Dependency = require('../dependency/Dependency');

var _Dependency2 = _interopRequireDefault(_Dependency);

var _ValidationLogger = require('../../interface/ValidationLogger');

var _ValidationLogger2 = _interopRequireDefault(_ValidationLogger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const log = new _zosLib.Logger('LocalController');

const DEFAULT_VERSION = '0.1.0';

class LocalBaseController {
  constructor(packageFile) {
    this.packageFile = packageFile;
  }

  get isLib() {
    return this.packageFile.isLib;
  }

  init(name, version, force = false) {
    this.initZosPackageFile(name, version, force);
    _Session2.default.ignoreFile();
    _Truffle2.default.init();
  }

  initZosPackageFile(name, version, force = false) {
    if (this.packageFile.exists() && !force) {
      throw Error(`Cannot overwrite existing file ${this.packageFile.fileName}`);
    }
    if (this.packageFile.name && !force) {
      throw Error(`Cannot initialize already initialized package ${this.packageFile.name}`);
    }
    this.packageFile.name = name;
    this.packageFile.version = version || DEFAULT_VERSION;
    this.packageFile.contracts = {};
  }

  bumpVersion(version) {
    this.packageFile.version = version;
  }

  add(contractAlias, contractName) {
    log.info(`Adding ${contractAlias === contractName ? contractAlias : `${contractAlias}:${contractName}`}`);
    this.packageFile.addContract(contractAlias, contractName);
  }

  addAll() {
    // TODO: hack to get local build dir, add this info to Contracts from zos-lib
    const folder = _zosLib.Contracts.getLocalPath('').replace(/\.json$/, '');
    _zosLib.FileSystem.readDir(folder).forEach(file => {
      const path = `${folder}/${file}`;
      if (this.hasBytecode(path)) {
        const contractData = _zosLib.FileSystem.parseJson(path);
        const contractName = contractData.contractName;
        this.add(contractName, contractName);
      }
    });
  }

  remove(contractAlias) {
    if (!this.packageFile.hasContract(contractAlias)) {
      log.error(`Contract ${contractAlias} to be removed was not found`);
    } else {
      log.info(`Removing ${contractAlias}`);
      this.packageFile.unsetContract(contractAlias);
    }
  }

  checkCanAdd(contractName) {
    const path = _zosLib.Contracts.getLocalPath(contractName);
    if (!_zosLib.FileSystem.exists(path)) {
      throw Error(`Contract ${contractName} not found in path ${path}`);
    }
    if (!this.hasBytecode(path)) {
      throw Error(`Contract ${contractName} is abstract and cannot be deployed.`);
    }
  }

  validateAll() {
    const buildArtifacts = (0, _zosLib.getBuildArtifacts)();
    return _lodash2.default.every(_lodash2.default.map(this.packageFile.contractAliases, contractAlias => this.validate(contractAlias, buildArtifacts)));
  }

  validate(contractAlias, buildArtifacts) {
    const contractName = this.packageFile.contract(contractAlias);
    const contractClass = _zosLib.Contracts.getFromLocal(contractName || contractAlias);
    const warnings = (0, _zosLib.validate)(contractClass, {}, buildArtifacts);
    new _ValidationLogger2.default(contractClass).log(warnings, buildArtifacts);
    return (0, _zosLib.validationPasses)(warnings);
  }

  hasBytecode(contractDataPath) {
    if (!_zosLib.FileSystem.exists(contractDataPath)) return false;
    const bytecode = _zosLib.FileSystem.parseJson(contractDataPath).bytecode;
    return bytecode && bytecode !== "0x";
  }

  getContractClass(packageName, contractAlias) {
    if (!packageName || packageName === this.packageFile.name) {
      const contractName = this.packageFile.contract(contractAlias);
      return _zosLib.Contracts.getFromLocal(contractName);
    } else {
      const dependency = new _Dependency2.default(packageName);
      const contractName = dependency.getPackageFile().contract(contractAlias);
      return _zosLib.Contracts.getFromNodeModules(packageName, contractName);
    }
  }

  getContractSourcePath(contractAlias) {
    const contractName = this.packageFile.contract(contractAlias);
    if (contractName) {
      const contractDataPath = _zosLib.Contracts.getLocalPath(contractName);
      const { compiler, sourcePath } = _zosLib.FileSystem.parseJson(contractDataPath);
      return { sourcePath, compilerVersion: compiler.version };
    } else {
      throw Error(`Could not find ${contractAlias} in contracts directory.`);
    }
  }

  writePackage() {
    this.packageFile.write();
  }
}
exports.default = LocalBaseController;