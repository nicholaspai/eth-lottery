'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _zosLib = require('zos-lib');

var _naming = require('../../utils/naming');

var _ZosVersion = require('./ZosVersion');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const log = new _zosLib.Logger('ZosNetworkFile');

class ZosNetworkFile {

  constructor(packageFile, network, fileName) {
    this.packageFile = packageFile;
    this.network = network;
    this.fileName = fileName;

    const defaults = this.packageFile.isLib ? { contracts: {}, solidityLibs: {}, lib: true, frozen: false, zosversion: _ZosVersion.ZOS_VERSION } : { contracts: {}, solidityLibs: {}, proxies: {}, zosversion: _ZosVersion.ZOS_VERSION };

    this.data = _zosLib.FileSystem.parseJsonIfExists(this.fileName) || defaults;
    (0, _ZosVersion.checkVersion)(this.data.zosversion, this.fileName);
  }

  get app() {
    return this.data.app || {};
  }

  get appAddress() {
    return this.app.address;
  }

  get package() {
    return this.data.package || {};
  }

  get packageAddress() {
    return this.package.address;
  }

  get provider() {
    return this.data.provider || {};
  }

  get providerAddress() {
    return this.provider.address;
  }

  get version() {
    return this.data.version;
  }

  get frozen() {
    return this.data.frozen;
  }

  get contracts() {
    return this.data.contracts || {};
  }

  get contractAliases() {
    return Object.keys(this.contracts);
  }

  get isLib() {
    return this.packageFile.isLib;
  }

  get isLightweight() {
    return this.packageFile.isLightweight;
  }

  get solidityLibs() {
    return this.data.solidityLibs || {};
  }

  addSolidityLib(libName, instance) {
    this.data.solidityLibs[libName] = {
      address: instance.address,
      constructorCode: (0, _zosLib.constructorCode)(instance),
      bodyBytecodeHash: (0, _zosLib.bytecodeDigest)((0, _zosLib.bodyCode)(instance)),
      localBytecodeHash: (0, _zosLib.bytecodeDigest)(instance.constructor.bytecode),
      deployedBytecodeHash: (0, _zosLib.bytecodeDigest)(instance.constructor.binary)
    };
  }

  unsetSolidityLib(libName) {
    delete this.data.solidityLibs[libName];
  }

  setSolidityLib(alias, value) {
    if (!this.data.solidityLibs) this.data.solidityLibs = {};
    this.data.solidityLibs[alias] = value;
  }

  solidityLib(libName) {
    return this.data.solidityLibs[libName];
  }

  getSolidityLibs(libs) {
    const { solidityLibs } = this.data;

    return Object.keys(solidityLibs).filter(libName => libs.includes(libName)).map(libName => ({ libName, address: solidityLibs[libName].address })).reduce((libs, currentLib) => {
      libs[currentLib.libName] = currentLib.address;
      return libs;
    }, {});
  }

  hasSolidityLib(libName) {
    return !_lodash2.default.isEmpty(this.solidityLib(libName));
  }

  solidityLibsMissing(libs) {
    return _lodash2.default.difference(Object.keys(this.solidityLibs), libs);
  }

  getSolidityLibOrContract(aliasOrName) {
    return this.data.solidityLibs[aliasOrName] || this.data.contracts[aliasOrName];
  }

  hasSolidityLibOrContract(aliasOrName) {
    return this.hasSolidityLib(aliasOrName) || this.hasContract(aliasOrName);
  }

  updateImplementation(aliasOrName, fn) {
    if (this.hasContract(aliasOrName)) {
      this.data.contracts[aliasOrName] = fn(this.data.contracts[aliasOrName]);
    } else if (this.hasSolidityLib(aliasOrName)) {
      this.data.solidityLibs[aliasOrName] = fn(this.data.solidityLibs[aliasOrName]);
    } else {
      return;
    }
  }

  get dependencies() {
    return this.data.dependencies || {};
  }

  get dependenciesNames() {
    return Object.keys(this.dependencies);
  }

  getDependency(name) {
    if (!this.data.dependencies) return null;
    return this.data.dependencies[name] || {};
  }

  hasDependency(name) {
    return !_lodash2.default.isEmpty(this.getDependency(name));
  }

  hasDependencies() {
    return !_lodash2.default.isEmpty(this.dependencies);
  }

  getProxies({ package: packageName, contract, address } = {}) {
    if (_lodash2.default.isEmpty(this.data.proxies)) return [];
    const allProxies = _lodash2.default.flatMap(this.data.proxies || {}, (proxiesList, fullname) => _lodash2.default.map(proxiesList, proxyInfo => _extends({}, (0, _naming.fromContractFullName)(fullname), proxyInfo)));
    return _lodash2.default.filter(allProxies, proxy => (!packageName || proxy.package === packageName) && (!contract || proxy.contract === contract) && (!address || proxy.address === address));
  }

  getProxy(address) {
    const allProxies = this.getProxies();
    return _lodash2.default.find(allProxies, { address });
  }

  contract(alias) {
    return this.data.contracts[alias];
  }

  contractAliasesMissingFromPackage() {
    return _lodash2.default.difference(this.contractAliases, this.packageFile.contractAliases);
  }

  isCurrentVersion(version) {
    return this.version === version;
  }

  hasContract(alias) {
    return !_lodash2.default.isEmpty(this.contract(alias));
  }

  hasContracts() {
    return !_lodash2.default.isEmpty(this.data.contracts);
  }

  hasProxies(filter = {}) {
    return !_lodash2.default.isEmpty(this.getProxies(filter));
  }

  hasMatchingVersion() {
    return this.packageFile.isCurrentVersion(this.version);
  }

  dependenciesNamesMissingFromPackage() {
    return _lodash2.default.difference(this.dependenciesNames, this.packageFile.dependenciesNames);
  }

  dependencyHasCustomDeploy(name) {
    const dep = this.getDependency(name);
    return dep && dep.customDeploy;
  }

  dependencySatisfiesVersionRequirement(name) {
    const dep = this.getDependency(name);
    return dep && this.packageFile.dependencyMatches(name, dep.version);
  }

  dependencyHasMatchingCustomDeploy(name) {
    return this.dependencyHasCustomDeploy(name) && this.dependencySatisfiesVersionRequirement(name);
  }

  hasSameBytecode(alias, klass) {
    const contract = this.contract(alias) || this.solidityLib(alias);
    if (contract) {
      const localBytecode = contract.localBytecodeHash;
      const currentBytecode = (0, _zosLib.bytecodeDigest)(klass.bytecode);
      return currentBytecode === localBytecode;
    }
  }

  set version(version) {
    this.data.version = version;
  }

  set contracts(contracts) {
    this.data.contracts = contracts;
  }

  set solidityLibs(solidityLibs) {
    this.data.solidityLibs = solidityLibs;
  }

  set frozen(frozen) {
    this.data.frozen = frozen;
  }

  set app(app) {
    this.data.app = app;
  }

  set provider(provider) {
    this.data.provider = provider;
  }

  set package(_package) {
    this.data.package = _package;
  }

  setDependency(name, { package: thepackage, version, customDeploy } = {}) {
    if (!this.data.dependencies) {
      this.data.dependencies = {};
    }

    const dependency = {
      package: thepackage,
      version: (0, _zosLib.semanticVersionToString)(version)
    };
    if (customDeploy) {
      dependency.customDeploy = customDeploy;
    }

    this.data.dependencies[name] = dependency;
  }

  unsetDependency(name) {
    if (!this.data.dependencies) return;
    delete this.data.dependencies[name];
  }

  updateDependency(name, fn) {
    this.setDependency(name, fn(this.getDependency(name)));
  }

  addContract(alias, instance, { warnings, types, storage } = {}) {
    this.setContract(alias, {
      address: instance.address,
      constructorCode: (0, _zosLib.constructorCode)(instance),
      bodyBytecodeHash: (0, _zosLib.bytecodeDigest)((0, _zosLib.bodyCode)(instance)),
      localBytecodeHash: (0, _zosLib.bytecodeDigest)(instance.constructor.bytecode),
      deployedBytecodeHash: (0, _zosLib.bytecodeDigest)(instance.constructor.binary),
      types,
      storage,
      warnings
    });
  }

  setContract(alias, value) {
    this.data.contracts[alias] = value;
  }

  unsetContract(alias) {
    delete this.data.contracts[alias];
  }

  setProxies(packageName, alias, value) {
    const fullname = (0, _naming.toContractFullName)(packageName, alias);
    this.data.proxies[fullname] = value;
  }

  addProxy(thepackage, alias, info) {
    const fullname = (0, _naming.toContractFullName)(thepackage, alias);
    if (!this.data.proxies[fullname]) this.data.proxies[fullname] = [];
    this.data.proxies[fullname].push(info);
  }

  removeProxy(thepackage, alias, address) {
    const fullname = (0, _naming.toContractFullName)(thepackage, alias);
    const index = this._indexOfProxy(fullname, address);
    if (index < 0) return;
    this.data.proxies[fullname].splice(index, 1);
    if (this._proxiesOf(fullname).length === 0) delete this.data.proxies[fullname];
  }

  updateProxy({ package: proxyPackageName, contract: proxyContractName, address: proxyAddress }, fn) {
    const fullname = (0, _naming.toContractFullName)(proxyPackageName, proxyContractName);
    const index = this._indexOfProxy(fullname, proxyAddress);
    if (index === -1) throw Error(`Proxy ${fullname} at ${proxyAddress} not found in network file`);
    this.data.proxies[fullname][index] = fn(this.data.proxies[fullname][index]);
  }

  _indexOfProxy(fullname, address) {
    return _lodash2.default.findIndex(this.data.proxies[fullname], { address });
  }

  _proxiesOf(fullname) {
    return this.data.proxies[fullname] || [];
  }

  write() {
    if (this._hasChanged()) {
      const exists = this._exists();
      _zosLib.FileSystem.writeJson(this.fileName, this.data);
      exists ? log.info(`Updated ${this.fileName}`) : log.info(`Created ${this.fileName}`);
    }
  }

  _hasChanged() {
    const currentNetworkFile = _zosLib.FileSystem.parseJsonIfExists(this.fileName);
    return !_lodash2.default.isEqual(this.data, currentNetworkFile);
  }

  _exists() {
    return !!_zosLib.FileSystem.parseJsonIfExists(this.fileName);
  }
}
exports.default = ZosNetworkFile;