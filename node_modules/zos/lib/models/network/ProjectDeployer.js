"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AppProjectDeployer = exports.LibProjectDeployer = exports.SimpleProjectDeployer = undefined;

var _zosLib = require("zos-lib");

var _lodash = require("lodash");

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class BaseProjectDeployer {
  constructor(controller, requestedVersion) {
    this.controller = controller;
    this.packageFile = controller.packageFile;
    this.networkFile = controller.networkFile;
    this.txParams = controller.txParams;
    this.requestedVersion = requestedVersion;
  }
}

class BasePackageProjectDeployer extends BaseProjectDeployer {
  get packageAddress() {
    return this.controller.packageAddress;
  }

  _tryRegisterPartialDeploy({ thepackage, directory }) {
    if (thepackage) this._registerPackage(thepackage);
    if (directory) this._registerVersion(this.requestedVersion, directory);
  }

  _registerPackage({ address }) {
    this.networkFile.package = { address };
  }

  _registerVersion(version, { address }) {
    this.networkFile.provider = { address };
    this.networkFile.version = version;
  }
}

class SimpleProjectDeployer extends BaseProjectDeployer {
  async fetchOrDeploy() {
    this.project = new _zosLib.SimpleProject(this.packageFile.name, this.txParams);
    this.networkFile.version = this.requestedVersion;
    _lodash2.default.forEach(this.networkFile.contracts, (contractInfo, contractAlias) => {
      this.project.registerImplementation(contractAlias, contractInfo);
    });
    _lodash2.default.forEach(this.networkFile.dependencies, (dependencyInfo, dependencyName) => {
      this.project.setDependency(dependencyName, dependencyInfo.package, dependencyInfo.version);
    });

    return this.project;
  }
}

exports.SimpleProjectDeployer = SimpleProjectDeployer;
class LibProjectDeployer extends BasePackageProjectDeployer {
  async fetchOrDeploy() {
    try {
      const packageAddress = this.packageAddress;
      this.project = await _zosLib.LibProject.fetchOrDeploy(this.requestedVersion, this.txParams, { packageAddress });
      this._registerPackage((await this.project.getProjectPackage()));
      this._registerVersion(this.requestedVersion, (await this.project.getCurrentDirectory()));
      return this.project;
    } catch (deployError) {
      this._tryRegisterPartialDeploy(deployError);
      if (!this.project) throw deployError;
    }
  }
}

exports.LibProjectDeployer = LibProjectDeployer;
class AppProjectDeployer extends BasePackageProjectDeployer {
  async fetchOrDeploy() {
    return this._run(existingAddresses => _zosLib.AppProject.fetchOrDeploy(this.packageFile.name, this.requestedVersion, this.txParams, existingAddresses));
  }

  async fromSimpleProject(simpleProject) {
    return this._run(existingAddresses => _zosLib.AppProject.fromSimpleProject(simpleProject, this.requestedVersion, this.txParams, existingAddresses));
  }

  get appAddress() {
    return this.controller.appAddress;
  }

  async _run(createProjectFn) {
    try {
      const { appAddress, packageAddress } = this;
      this.project = await createProjectFn({ appAddress, packageAddress });
      await this._registerDeploy();
      return this.project;
    } catch (deployError) {
      this._tryRegisterPartialDeploy(deployError);
      if (!this.project) throw deployError;
    }
  }

  async _registerDeploy() {
    this._registerApp(this.project.getApp());
    this._registerPackage((await this.project.getProjectPackage()));
    this._registerVersion(this.requestedVersion, (await this.project.getCurrentDirectory()));
  }

  _tryRegisterPartialDeploy({ thepackage, app, directory }) {
    super._tryRegisterPartialDeploy({ thepackage, directory });
    if (app) this._registerApp(app);
  }

  _registerApp({ address }) {
    this.networkFile.app = { address };
  }
}
exports.AppProjectDeployer = AppProjectDeployer;