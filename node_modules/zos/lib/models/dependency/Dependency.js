'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _zosLib = require('zos-lib');

var _semver = require('semver');

var _semver2 = _interopRequireDefault(_semver);

var _npmProgrammatic = require('npm-programmatic');

var _npmProgrammatic2 = _interopRequireDefault(_npmProgrammatic);

var _ZosPackageFile = require('../files/ZosPackageFile');

var _ZosPackageFile2 = _interopRequireDefault(_ZosPackageFile);

var _ZosNetworkFile = require('../files/ZosNetworkFile');

var _ZosNetworkFile2 = _interopRequireDefault(_ZosNetworkFile);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const log = new _zosLib.Logger('Dependency');

class Dependency {
  static fromNameWithVersion(nameAndVersion) {
    const [name, version] = nameAndVersion.split('@');
    return new this(name, version);
  }

  static satisfiesVersion(version, requirement) {
    return !requirement || version === requirement || _semver2.default.satisfies(version, requirement);
  }

  static async install(nameAndVersion) {
    log.info(`Installing ${nameAndVersion} via npm...`);
    await _npmProgrammatic2.default.install([nameAndVersion], { save: true, cwd: process.cwd() });
    return this.fromNameWithVersion(nameAndVersion);
  }

  constructor(name, requirement) {
    this.name = name;
    this._networkFiles = {};

    const packageVersion = this.getPackageFile().version;
    this._validateSatisfiesVersion(packageVersion, requirement);
    this.version = packageVersion;
    this.nameAndVersion = `${name}@${packageVersion}`;
    this.requirement = requirement || tryWithCaret(packageVersion);
  }

  async deploy(txParams) {
    const version = _semver2.default.coerce(this.version).toString();
    const project = await _zosLib.LibProject.fetchOrDeploy(version, txParams, {});

    // REFACTOR: Logic for filling in solidity libraries is partially duplicated from network base controller,
    // this should all be handled at the Project level. Consider adding a setImplementations (plural) method
    // to Projects, which handle library deployment and linking for a set of contracts altogether.

    const contracts = _lodash2.default.map(this.getPackageFile().contracts, (contractName, contractAlias) => [_zosLib.Contracts.getFromNodeModules(this.name, contractName), contractAlias]);

    const libraryNames = (0, _lodash2.default)(contracts).map(([contractClass]) => (0, _zosLib.getSolidityLibNames)(contractClass.bytecode)).flatten().uniq().value();

    const libraries = _lodash2.default.fromPairs((await Promise.all(_lodash2.default.map(libraryNames, async libraryName => {
      const implementation = await project.setImplementation(_zosLib.Contracts.getFromNodeModules(this.name, libraryName), libraryName);
      return [libraryName, implementation.address];
    }))));

    await Promise.all(_lodash2.default.map(contracts, async ([contractClass, contractAlias]) => {
      contractClass.link(libraries);
      await project.setImplementation(contractClass, contractAlias);
    }));

    return project;
  }

  getPackageFile() {
    if (!this._packageFile) {
      const filename = `node_modules/${this.name}/zos.json`;
      if (!_zosLib.FileSystem.exists(filename)) {
        throw Error(`Could not find a zos.json file for '${this.name}'. Make sure it is provided by the npm package.`);
      }
      this._packageFile = new _ZosPackageFile2.default(filename);
    }
    return this._packageFile;
  }

  getNetworkFile(network) {
    if (!this._networkFiles[network]) {
      const filename = this._getNetworkFilePath(network);
      if (!_zosLib.FileSystem.exists(filename)) {
        throw Error(`Could not find a zos file for network '${network}' for '${this.name}'`);
      }

      this._networkFiles[network] = new _ZosNetworkFile2.default(this.getPackageFile(), network, filename);
      this._validateSatisfiesVersion(this._networkFiles[network].version, this.requirement);
    }
    return this._networkFiles[network];
  }

  isDeployedOnNetwork(network) {
    const filename = this._getNetworkFilePath(network);
    if (!_zosLib.FileSystem.exists(filename)) return false;
    return !!this.getNetworkFile(network).packageAddress;
  }

  _getNetworkFilePath(network) {
    return `node_modules/${this.name}/zos.${network}.json`;
  }

  _validateSatisfiesVersion(version, requirement) {
    if (!Dependency.satisfiesVersion(version, requirement)) {
      throw Error(`Required dependency version ${requirement} does not match version ${version}`);
    }
  }
}

exports.default = Dependency;
function tryWithCaret(version) {
  const cleaned = _semver2.default.clean(version);
  return cleaned ? `^${cleaned}` : version;
}